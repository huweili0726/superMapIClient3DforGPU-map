<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <title>雷达扫描</title>
    <link href="../../Build/SuperMap3D/Widgets/widgets.css" rel="stylesheet">
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <link href="./css/pretty.css" rel="stylesheet">
    <link href="./css/bootstrap-select.min.css" rel="stylesheet">
    <script src="./js/jquery.min.js"></script>
    <script src="./js/bootstrap.min.js"></script>
    <script src="./js/bootstrap-select.min.js"></script>
    <script src="./js/config.js"></script>
    <script src="./js/shader/ScanSegmentShader.js"></script>
    <script src="./js/shader/CircleWaveShader.js"></script>
    <script type="text/javascript" src="../../Build/SuperMap3D/SuperMap3D.js"></script>
</head>

<body>
    <div id="Container"></div>
    <div id='loadingbar' class="spinner">
        <div class="spinner-container container1">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
        <div class="spinner-container container2">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
        <div class="spinner-container container3">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
    </div>

    <script>
        function onload(SuperMap3D) {
            // 通过config.js中的getEngineType,获取引擎类型（EngineType）用于设置启动方式
            let EngineType = getEngineType();
            let viewer = new SuperMap3D.Viewer('Container', {
                navigation: false,
                contextOptions: {
                    contextType: Number(EngineType), // Webgl2:2 ; WebGPU:3
                },
            });

            viewer.resolutionScale = window.devicePixelRatio;

            viewer.scenePromise.then(function (scene) {
                init(SuperMap3D, scene, viewer);
            });
        }

        function init(SuperMap3D, scene, viewer) {
            // 加载高德影像地图
            viewer.imageryLayers.addImageryProvider(new SuperMap3D.UrlTemplateImageryProvider({
                url: 'https://webst02.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
                minimumLevel: 3,
                maximumLevel: 18,
            }));

            let promise = viewer.scene.open(URL_CONFIG.SCENE_CBD);
            promise.then(function () {

                // 雷达扫描
                specialEffects();

                // 蓝色单线圈
                viewer.entities.add({
                    name: "中服大厦",
                    position: new SuperMap3D.Cartesian3.fromDegrees(116.45709236589721, 39.90800217738526, 0),
                    ellipse: {
                        height: 100, // 线圈的高度
                        semiMinorAxis: 100, // 线圈的横向长度
                        semiMajorAxis: 100, // 线圈的竖向长度
                        material: new SuperMap3D.CircleWaveMaterialProperty(
                            SuperMap3D.Color.fromCssColorString("rgba(1, 213, 222, 0.6)"),
                            2e3,
                            1,
                            0
                        ), // 第一个参数是线圈的颜色，第二个参数是线圈的个数
                        distanceDisplayCondition: new SuperMap3D.DistanceDisplayCondition(
                            500.0,
                            15000.0
                        ), // 在限定高度范围内才显示线圈
                    },
                });

                // 红色多线圈
                viewer.entities.add({
                    name: "中国国际贸易中心",
                    position: new SuperMap3D.Cartesian3.fromDegrees(116.45419139101804, 39.90952568647991, 0),
                    ellipse: {
                        height: 100,
                        semiMinorAxis: 100,
                        semiMajorAxis: 100,
                        material: new SuperMap3D.CircleWaveMaterialProperty(
                            SuperMap3D.Color.fromCssColorString("#E54030"),
                            2e3,
                            3,
                            0
                        ),
                    },
                });

                // 雷达扫描
                let CartographicCenter = new SuperMap3D.Cartographic(SuperMap3D.Math.toRadians(116.45755317128251), SuperMap3D.Math.toRadians(39.9135025039506), 0);
                let scanColor = new SuperMap3D.Color(1.0, 0.0, 0.0, 1);
                AddRadarScanPostStage(viewer, CartographicCenter, 300, scanColor, 4000);

                viewer.camera.setView({
                    destination: { x: -2183234.498516853, y: 4387108.983506769, z: 4070220.1676190905 },
                    orientation: {
                        heading: 0.00001649512392720709,
                        pitch: -0.748522239392404,
                        roll: 7.459898565542744e-8
                    }
                });
            })

            /**
            * @description: 雷达扫描后处理效果
            * @param {*} cartographicCenter：扫描中心
            * @param {*} radius：半径 米
            * @param {*} scanColor：扫描颜色
            * @param {*} duration：持续时间 毫秒
            */
            function AddRadarScanPostStage(viewer, cartographicCenter, radius, scanColor, duration) {
                let _Cartesian3Center = SuperMap3D.Cartographic.toCartesian(cartographicCenter);
                let _Cartesian4Center = new SuperMap3D.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);
                let _CartographicCenter1 = new SuperMap3D.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);
                let _Cartesian3Center1 = SuperMap3D.Cartographic.toCartesian(_CartographicCenter1);
                let _Cartesian4Center1 = new SuperMap3D.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);
                let _CartographicCenter2 = new SuperMap3D.Cartographic(cartographicCenter.longitude + SuperMap3D.Math.toRadians(0.001), cartographicCenter.latitude, cartographicCenter.height);
                let _Cartesian3Center2 = SuperMap3D.Cartographic.toCartesian(_CartographicCenter2);
                let _Cartesian4Center2 = new SuperMap3D.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1);
                let _RotateQ = new SuperMap3D.Quaternion();
                let _RotateM = new SuperMap3D.Matrix3();
                let _time = (new Date()).getTime();
                let _scratchCartesian4Center = new SuperMap3D.Cartesian4();
                let _scratchCartesian4Center1 = new SuperMap3D.Cartesian4();
                let _scratchCartesian4Center2 = new SuperMap3D.Cartesian4();
                let _scratchCartesian3Normal = new SuperMap3D.Cartesian3();
                let _scratchCartesian3Normal1 = new SuperMap3D.Cartesian3();
                let ScanPostStage = new SuperMap3D.PostProcessStage({
                    name : 'scanPost',
                    fragmentShader: ScanSegmentShader,
                    uniforms: {
                        u_scanCenterEC: function () {
                            return SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                        },
                        u_scanPlaneNormalEC: function () {
                            let temp = SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                            let temp1 = SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
                            _scratchCartesian3Normal.x = temp1.x - temp.x;
                            _scratchCartesian3Normal.y = temp1.y - temp.y;
                            _scratchCartesian3Normal.z = temp1.z - temp.z;
                            SuperMap3D.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
                            return _scratchCartesian3Normal;
                        },
                        u_radius: radius,
                        u_scanLineNormalEC: function () {
                            let temp = SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
                            let temp1 = SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
                            let temp2 = SuperMap3D.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2);
                            _scratchCartesian3Normal.x = temp1.x - temp.x;
                            _scratchCartesian3Normal.y = temp1.y - temp.y;
                            _scratchCartesian3Normal.z = temp1.z - temp.z;
                            SuperMap3D.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
                            _scratchCartesian3Normal1.x = temp2.x - temp.x;
                            _scratchCartesian3Normal1.y = temp2.y - temp.y;
                            _scratchCartesian3Normal1.z = temp2.z - temp.z;
                            let tempTime = (((new Date()).getTime() - _time) % duration) / duration;
                            SuperMap3D.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * SuperMap3D.Math.PI * 2, _RotateQ);
                            SuperMap3D.Matrix3.fromQuaternion(_RotateQ, _RotateM);
                            SuperMap3D.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1);
                            SuperMap3D.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1);
                            return _scratchCartesian3Normal1;
                        },
                        u_scanColor: scanColor
                    }
                });
                viewer.scene.postProcessStages.add(ScanPostStage);
            }

            // 圆圈扩散特效实例
            function specialEffects() {
                function CircleWaveMaterialProperty(color, duration, count, gradient) {
                    this._definitionChanged = new SuperMap3D.Event()
                    this._color = undefined
                    this._colorSubscription = undefined
                    this.color = color
                    this.duration = SuperMap3D.defaultValue(duration, 1e3)
                    this.count = SuperMap3D.defaultValue(count, 2)
                    if (this.count <= 0) this.count = 1
                    this.gradient = SuperMap3D.defaultValue(gradient, 0.1)
                    if (this.gradient < 0) this.gradient = 0
                    else if (this.gradient > 1) this.gradient = 1
                    this._time = performance.now()
                }
                Object.defineProperties(CircleWaveMaterialProperty.prototype, {
                    isConstant: {
                        get: function () {
                            return false
                        }
                    },
                    definitionChanged: {
                        get: function () {
                            return this._definitionChanged
                        }
                    },
                    color: SuperMap3D.createPropertyDescriptor('color')
                })
                CircleWaveMaterialProperty.prototype.getType = function (time) {
                    return SuperMap3D.Material.CircleWaveMaterialType
                }
                CircleWaveMaterialProperty.prototype.getValue = function (time, result) {
                    if (!SuperMap3D.defined(result)) {
                        result = {}
                    }
                    result.color = SuperMap3D.Property.getValueOrClonedDefault(this._color, time, SuperMap3D.Color.WHITE, result.color)
                    result.time = (((new Date()).getTime() - this._time) % this.duration) / this.duration
                    result.count = this.count
                    result.gradient = 1 + 10 * (1 - this.gradient)
                    return result
                }
                CircleWaveMaterialProperty.prototype.equals = function (other) {
                    return this === other ||
                        (other instanceof CircleWaveMaterialProperty &&
                            SuperMap3D.Property.equals(this._color, other._color))
                }
                SuperMap3D.CircleWaveMaterialProperty = CircleWaveMaterialProperty
                SuperMap3D.Material.CircleWaveMaterialType = 'CircleWaveMaterial'
                SuperMap3D.Material.CircleWaveSource = CircleWaveShader;
                SuperMap3D.Material._materialCache.addMaterial(SuperMap3D.Material.CircleWaveMaterialType, {
                    fabric: {
                        type: SuperMap3D.Material.CircleWaveMaterialType,
                        uniforms: {
                            color: new SuperMap3D.Color(1.0, 0.0, 0.0, 1.0),
                            time: 1,
                            count: 1,
                            gradient: 0.1
                        },
                        source: SuperMap3D.Material.CircleWaveSource
                    },
                    translucent: function (material) {
                        return !0
                    }
                })
            }

            $('#loadingbar').remove();
        }
        if (typeof SuperMap3D !== 'undefined') {
            window.startupCalled = true;
            onload(SuperMap3D);
        }
    </script>
</body>

</html>