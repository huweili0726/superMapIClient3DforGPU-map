<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>流动纹理</title>
  <link href="../../Build/SuperMap3D/Widgets/widgets.css" rel="stylesheet">
  <link href="./css/pretty.css" rel="stylesheet">
  <script src="./js/jquery.min.js"></script>
  <script src="./js/config.js"></script>
  <script type="text/javascript" src="../../Build/SuperMap3D/SuperMap3D.js"></script>
</head>

<body>
  <div id="Container"></div>
  <div id='loadingbar' class="spinner">
    <div class="spinner-container container1">
      <div class="circle1"></div>
      <div class="circle2"></div>
      <div class="circle3"></div>
      <div class="circle4"></div>
    </div>
    <div class="spinner-container container2">
      <div class="circle1"></div>
      <div class="circle2"></div>
      <div class="circle3"></div>
      <div class="circle4"></div>
    </div>
    <div class="spinner-container container3">
      <div class="circle1"></div>
      <div class="circle2"></div>
      <div class="circle3"></div>
      <div class="circle4"></div>
    </div>
  </div>
  <script>
    function onload(SuperMap3D) {
      const viewer = new SuperMap3D.Viewer('Container', {
        contextOptions: {
          contextType: 2  // Webgl2:2 ; WebGPU:3
        }
      });
      window.viewer = viewer;

      viewer.scenePromise.then(function (scene) {
        init(SuperMap3D, scene, viewer);
      });
    }
    function init(SuperMap3D, scene, viewer) {
      viewer.resolutionScale = window.devicePixelRatio;
      $('#loadingbar').remove();

      const defaultColor = SuperMap3D.Color.TRANSPARENT;
      const defaultImage = '../../../assets/images/color.png';
      const defaultImageimageW = 10
      const defaultAnimation = false
      const defaultDuration = 3000;

      // 创建自定义材质
      function ImageLineMaterial(opt) {
        opt = SuperMap3D.defaultValue(opt, SuperMap3D.defaultValue.EMPTY_OBJECT);
        this._definitionChanged = new SuperMap3D.Event();
        // 定义材质变量
        this._color = undefined;
        this._colorSubscription = undefined;
        this._backgroundColor = undefined;
        this._backgroundColorSubscription = undefined;
        this._image = undefined;
        this._imageSubscription = undefined;
        this._imageW = undefined;
        this._imageWSubscription = undefined;
        this._animation = undefined;
        this._animationSubscription = undefined;
        this._duration = undefined;
        this._durationSubscription = undefined;
        // 变量初始化
        this.color = opt.color || defaultColor; //颜色
        this.backgroundColor = opt.backgroundColor || defaultColor; //颜色
        this._image = opt.image || defaultImage; //材质图片
        this.imageW = opt.imageW || defaultImageimageW
        this.animation = opt.animation || defaultAnimation
        this.duration = opt.duration || defaultDuration
        this._time = undefined;
      }
      ImageLineMaterial.prototype.getType = function (time) {
        return "ImageLine";
      };
      ImageLineMaterial.prototype.getValue = function (time, result) {
        if (!SuperMap3D.defined(result)) {
          result = {};
        }
        result.color = SuperMap3D.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
        result.backgroundColor = SuperMap3D.Property.getValueOrClonedDefault(this._backgroundColor, time, defaultColor, result.backgroundColor);
        result.image = this._image;
        result.imageW = this._imageW;
        result.animation = this._animation;
        if (this._time === undefined) {
          this._time = new Date().getTime();
        }
        result.time = ((new Date().getTime() - this._time) % this._duration) / this._duration;
        return result;
      };
      ImageLineMaterial.prototype.equals = function (other) {
        return this === other ||
          other instanceof ImageLineMaterial && SuperMap3D.Property.equals(this._color, other._color) && SuperMap3D.Property.equals(this._backgroundColor, other._backgroundColor);
      };
      Object.defineProperties(ImageLineMaterial.prototype, {
        isConstant: {
          get: function get() {
            return false;
          }
        },
        definitionChanged: {
          get: function get() {
            return this._definitionChanged;
          }
        },
        color: SuperMap3D.createPropertyDescriptor('color'),
        backgroundColor: SuperMap3D.createPropertyDescriptor('backgroundColor'),
        image: SuperMap3D.createPropertyDescriptor('image'),
        imageW: SuperMap3D.createPropertyDescriptor('imageW'),
        animation: SuperMap3D.createPropertyDescriptor('animation'),
        duration: SuperMap3D.createPropertyDescriptor('duration'),
      });

      SuperMap3D.Material._materialCache.addMaterial("ImageLine", {
        fabric: {
          type: "ImageLine",
          uniforms: {
            color: new SuperMap3D.Color(1, 0, 0, 1.0),
            backgroundColor: new SuperMap3D.Color(0, 0, 0, 0.0),
            image: '',
            imageW: 1,
            animation: false,
            duration: 30,
            time: 0
          },
          source: `varying float v_polylineAngle;
                    mat2 rotate(float rad) {
                      float c = cos(rad);
                      float s = sin(rad);
                      return mat2(
                          c, s,
                          -s, c
                      );
                    }
                    czm_material czm_getMaterial(czm_materialInput materialInput)
                    {
                      czm_material material = czm_getDefaultMaterial(materialInput);
                      vec2 st = materialInput.st;
                      vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;
                      float s = pos.x / (imageW * czm_pixelRatio);
                      s = s - time;
                      float t = st.t;
                      vec4 colorImage = texture2D(image, vec2(fract(s), t));
                        material.diffuse = colorImage.rgb; 
                        if(colorImage.r == 0.0 ){ // 过滤掉黑色背景
                          material.alpha = 0.0; 
                        }
                        
                        return material;
                    }`
        },
        translucent: function translucent() {
          return true;
        }
      });
      SuperMap3D.Material.ImageLineType = 'ImageLine'
      SuperMap3D.ImageLineMaterialProperty = ImageLineMaterial;

      const promise = viewer.scene.open(URL_CONFIG.SCENE_CBD);
      promise.then(function (layers) {
        viewer.scene.camera.setView({
          "destination": {
            "x": -2183427.4142402075,
            "y": 4386365.807857525,
            "z": 4070063.6072264393
          },
          "orientation": {
            "heading": 6.184769465949209,
            "pitch": -0.5609784191414846,
            "roll": 2.654124884315934e-7
          }
        });

        // 添加流动纹理
        const forward_points = [
          116.46351351895198, 39.90729895176164,
          116.46351320507556, 39.91196277076713
        ];
        const backward_points = [
          116.46341763323473, 39.91195737227497,
          116.46341778590792, 39.907293439019355
        ];
        function addLine(points, width) {
          const positions = SuperMap3D.Cartesian3.fromDegreesArray(points);
          let line = viewer.entities.add({
            polyline: {
              positions: positions,
              width: width,
              clampToGround: true,
              material: new SuperMap3D.ImageLineMaterialProperty({ //使用自定义的材质
                image: './images/flowing-arrow-icon.png',
                duration: 300
              })
            }
          })

          return line;
        }
        const forward_line = addLine(forward_points, 10);
        const backward_line = addLine(backward_points, 10);

        // 根据相机视角动态修改线实体的宽度
        viewer.camera.changed.addEventListener(function () {
          const distance = viewer.camera.positionCartographic.height;
          const width = 1.0 / (distance / 3000); // 计算缩放系数，根据实际情况调整参数
          // if (width > 30 || width < 5) return; // 距离太近太远时，固定宽度
          if (width > 30) return; 
          if (forward_line && forward_line.polyline) forward_line.polyline.width = width;
          if (backward_line && backward_line.polyline) backward_line.polyline.width = width;
        });
      })
    }

    if (typeof SuperMap3D !== 'undefined') {
      window.startupCalled = true;
      onload(SuperMap3D);
    }
  </script>
</body>

</html>