<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <title>多维度多时序水面</title>
    <link href="../../Build/SuperMap3D/Widgets/widgets.css" rel="stylesheet">
    <link rel="stylesheet" href="./style/temporalHydroAttrs.css">
    <link href="./style/vuecommon.css" rel="stylesheet">
    <script src="./js/config.js"></script>
    <script src="./js/layerTree/vue.global.js"></script>
    <script src="./js/layerTree/naive-ui.min.js"></script>
    <script src="../../Build/SuperMap3D/SuperMap3D.js"></script>

    <style>
        .n-slider-marks {
            color: rgba(255, 255, 255, 0.85);
        }
        .btn-row-item .n-button{
            width: 70px;
        }
    </style>
</head>

<body>
    <div id="Container"></div>
    <div class="vue-container" style="display: none;">
        <div id="app">
            <div class="panel-container">
                <div class="panel-header">
                    <div class="panel-header-title">多维度多时序水面</div>
                    <span class="panel-header-close" id="close">X</span>
                </div>

                <!-- vue component content -->
                <n-config-provider :theme-overrides="overridesTheme" :theme="darkTheme" style="margin-top: 20px;">
                    <n-scrollbar style="max-height: 520px;padding-right: 10px;" trigger="none">
                        <div class="row-item">
                            <span>选择字段要素</span>
                            <n-select style="width: 230px" v-model:value="state.fieldType" :options="state.fieldOptions"
                                :focusable="false" />
                        </div>

                        <div class="row-item">
                            <span>选择时序类型</span>
                            <n-select style="width: 230px" v-model:value="state.timeType" :options="state.timeOptions"
                                :focusable="false" />
                        </div>

                        <div class="row-item">
                            <span>设置颜色表</span>
                            <n-select style="width: 230px" v-model:value="state.colorType" :options="state.colorOptions"
                                :focusable="false" :render-label="renderColorTableLabel"/>
                        </div>

                        <div class="row-item">
                            <span>透明度</span>
                            <div class="slider-box" style="width: 61%;">
                                <n-slider v-model:value="state.opacity" :min="0.0" :max="1.0" :step="0.1" />
                            </div>
                        </div>

                        <div class="row-item">
                            <span>颜色表范围</span>
                            <div class="slider-box">
                                <n-slider style="width: 100%;" v-model:value="state.colorRange" :step="0.1" range
                                    :min="state.minMaxRange[0]" :max="state.minMaxRange[1]" />
                            </div>
                        </div>

                        <div class="row-item">
                            <span>字段范围</span>
                            <div class="slider-box">
                                <n-slider style="width: 100%;" v-model:value="state.fieldRange" :step="0.1" range
                                    :min="state.minMaxRange[0]" :max="state.minMaxRange[1]" />
                            </div>
                        </div>
                        <div class="row-item">
                            <span>水流方向</span>
                            <div class="slider-box" style="width: 140px; margin-left: 50px;">
                                <n-slider v-model:value="state.direction" :min="0.0" :max="360.0" :step="1" />
                            </div>
                            <n-input-number v-model:value="state.direction" style="width:60px" :min="0.0" :max="360.0"
                                :step="1" :focusable="false" :show-button="false">
                                <template #suffix>&deg;</template>
                            </n-input-number>
                        </div>

                        <div class="row-item">
                            <span>显示水流方向</span>
                            <n-checkbox v-model:checked="state.useArrow" style="margin-left: 10px;"></n-checkbox>
                            <div class="color-pick-box" style="width: 200px;margin-left: 0px;">
                                <n-color-picker v-model:value="state.arrowColor" :render-label="
                                    () => {
                                        return '';
                                    }
                                    " size="small" :disabled="!state.useArrow">
                                </n-color-picker>
                            </div>
                        </div>

                        <div class="slider-box" style="margin: 10px 0px;margin-right: 3px;">
                            <n-slider style="width: 100%;" v-model:value="state.timeValue" :step="0.1" :min="0.1"
                                :max="state.timeTemporalCount" :marks="state.marks" />
                        </div>

                        <div class="btn-row-item" style="margin-left: 110px;">
                            <n-button type="info" color="#3499E5" text-color="#fff" :focusable="false"
                                style="margin-right: 10px; margin-top: 10px;" id="startBtn" @click="start" v-if="!state.isStart">开始</n-button>
                            <n-button type="info" color="#3499E5" text-color="#fff" :focusable="false"
                                style="margin-right: 10px; margin-top: 10px;" id="stopBtn" @click="stop" v-else>暂停</n-button>
                            <n-button type="info" color="#3499E5" text-color="#fff" :focusable="false"
                                style="margin-right: 10px; margin-top: 10px;"  @click="continueStart">继续</n-button>
                            <n-button :focusable="false" text-color="#fff" @click="restart">重置</n-button>
                        </div>
                    </n-scrollbar>
                </n-config-provider>

            </div>
            <div class="legend-toolbar" style="width: 75px;padding-top: 0px;">
                <p style="text-align: center;">{{state.filedNameByTL}}</p>
                <div id="color-legend"></div>
            </div>
        </div>
    </div>
    <div class="loading-container">
        <div class="circle"></div>
    </div>
    <style type="text/css">
	.supermap3d-viewer-bottom {
		display: none;
	}
	</style>
    <script>
        function onload(SuperMap3D) {
            const viewer = new SuperMap3D.Viewer('Container', {
                contextOptions: {
                    contextType: Number(2),  // Webgl2:2 ; WebGPU:3
                    msaaLevel: 2,
                },
                timeline: true,
                useSuperMapOIT: true
            });

            viewer.scenePromise.then(function (scene) {
                init(SuperMap3D, scene, viewer);
            });
        }

        function init(SuperMap3D, scene, viewer) {
            viewer.resolutionScale = window.devicePixelRatio;
            const time = SuperMap3D.JulianDate.fromIso8601('2025-04-14T22:14:01.41501564129430335Z')
            viewer.clock.currentTime = time.clone();
			scene.skyAtmosphere.show = false;
            const sceneUrl = "http://www.supermapol.com/realspace/services/3D-shixu/rest/realspace";
            const layerName = "TSDBModelCache";
            
            //创建天空盒
            //创建天空盒
            let sunSkyBox = new SuperMap3D.SkyBox({
                sources: {
                    positiveX: './images/SkyBox/sunsetglow/Right.jpg',
                    negativeX: './images/SkyBox/sunsetglow/Left.jpg',
                    positiveY: './images/SkyBox/sunsetglow/Front.jpg',
                    negativeY: './images/SkyBox/sunsetglow/Back.jpg',
                    positiveZ: './images/SkyBox/sunsetglow/Up.jpg',
                    negativeZ: './images/SkyBox/sunsetglow/Down.jpg'
                }
            });
            let blueSkyBox = new SuperMap3D.SkyBox({
                sources: {
                    positiveX: './images/SkyBox/bluesky/Right.jpg',
                    negativeX: './images/SkyBox/bluesky/Left.jpg',
                    positiveY: './images/SkyBox/bluesky/Front.jpg',
                    negativeY: './images/SkyBox/bluesky/Back.jpg',
                    positiveZ: './images/SkyBox/bluesky/Up.jpg',
                    negativeZ: './images/SkyBox/bluesky/Down.jpg'
                }
            });
            let hdrSkyBox = new SuperMap3D.SkyBox({
                imageUrl: './images/SkyBox/panorama/HDR_night_4K.hdr'
            })
            let jpgSkyBox = new SuperMap3D.SkyBox({
                imageUrl: './images/SkyBox/panorama/HDR_cloud_4K.jpg'
            })
            defaultSkyBox = viewer.scene.skyBox;

            //初始化时把天空盒资源准备好
            function initialSkyBox() {
                if (scene.frameState.passes.render) {
                    sunSkyBox.update(scene.frameState, true);
                    blueSkyBox.update(scene.frameState, true);
                    scene.postRender.removeEventListener(initialSkyBox);
                }
            }
            scene.postRender.addEventListener(initialSkyBox);
            //相机上升到一定位置,天空盒出现渐变效果
            function gradualChange() {
                skyListener = function () {
                    let cameraHeight = scene.camera.positionCartographic.height;

                    let skyAtmosphereH1 = 22e4; // 大气开始渐变的最大高度
                    let skyBoxH1 = 15e4; // 天空开始渐变的最大高度
                    let skyBoxH2 = 12e4; // 天空开始渐变的最小高度
                    let bufferHeight = 1e4;
                    if (cameraHeight < skyAtmosphereH1 && SuperMap3D.defined(currentSkyBox)) {
                        let skyAtmosphereT = (cameraHeight - skyBoxH2) / (skyAtmosphereH1 - skyBoxH2);
                        if (skyAtmosphereT > 1.0) {
                            skyAtmosphereT = 1.0;
                        } else if (skyAtmosphereT < 0.0) {
                            skyAtmosphereT = 0.0;
                        }
                        let skyBoxT = (cameraHeight - skyBoxH2) / (skyBoxH1 - skyBoxH2);
                        if (skyBoxT > 1.0) {
                            skyBoxT = 1.0;
                        } else if (skyBoxT < 0.0) {
                            skyBoxT = 0.0;
                        }
                        currentSkyBox.alpha = 1.0 - skyBoxT;
                        if (cameraHeight > skyBoxH2) {
                            scene.skyAtmosphere.show = true;
                            scene.skyAtmosphere.alpha = skyAtmosphereT;
                            scene.skyBox = currentSkyBox;
                        } else {
                            scene.skyAtmosphere.show = false;
                        }
                    } else {
                        scene.skyAtmosphere.alpha = 1.0;
                        scene.skyBox = defaultSkyBox;
                    }

                    //控制相机 速率
                    if (scene.skyBox !== defaultSkyBox) {
                        if (cameraHeight > (skyBoxH2 - 2 * bufferHeight) && cameraHeight < skyBoxH1 + 3 * bufferHeight) {
                            scene.screenSpaceCameraController.zoomFactor = 0.4;
                        } else {
                            scene.screenSpaceCameraController.zoomFactor = 5.0;
                        }
                    } else {
                        scene.skyBox.alpha = 1.0;
                        scene.skyAtmosphere.alpha = 1.0;
                        scene.screenSpaceCameraController.zoomFactor = 5.0;
                    }

                };
                scene.postRender.addEventListener(skyListener);
            }

            //操作相机
            function handlerCamera(val) {
                let isSkyBox = handlerCloud;
                if (val == isSkyBox) {
                    scene.camera.flyTo({
                        destination: new SuperMap3D.Cartesian3(-5701705.704276292, 21279055.37816442, 12718852.74864528)
                    })
                } else {
                    scene.camera.flyTo({
                        destination: new SuperMap3D.Cartesian3(-2182943.9676850257, 4386804.912825742, 4069531.779775907),
                        orientation: {
                            heading: 6.228849889848172,
                            pitch: -0.0491143105095484,
                            roll: 2.973174177967053e-7
                        }
                    })
                };
            }
            
            hdrSkyBox.WSpeed = 0.5;
            hdrSkyBox.show = true;
            let currentSkyBox = hdrSkyBox;
            scene.skyBox = currentSkyBox;         

            // 加载高德影像地图
            viewer.imageryLayers.addImageryProvider(new SuperMap3D.UrlTemplateImageryProvider({
                url: 'https://webst02.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
                minimumLevel: 3,
                maximumLevel: 18,
            }));
            
            const promise = scene.open(sceneUrl);
            promise.then(function (layers) {
                document.querySelector('.loading-container').style.display = 'none';
                document.querySelector('.vue-container').style.display = 'block';

                // 初始化Vue组件
                initVueComponents(scene, viewer);
            })
        }

        // 初始化Vue组件
        function initVueComponents(scene, viewer) {
            // 对象解构
            const { reactive, watch, ref, h } = Vue;
            const { darkTheme } = naive;

            // 初始化变量
            const WaterbodySize = SuperMap3D.WaterbodySize;
            const WaveStrength = SuperMap3D.WaveStrength;
            const state = reactive({
                fieldType: "",
                fieldOptions: [],
                filedNameByTL:'水深(m)',
                timeType: "",
                timeOptions: [],
                colorType: '',
                colorOptions: [
                    // { label: '碧绿', value:"1" , bgColor: '-webkit-linear-gradient(left, #00A2FF, #0082FF, #008CFF, #0096FF, #00B9FF, #00C4FF, #00A0FF, #9AFF00, #00FF8C, #FFC400, #005CE6)' },
                    // { label: '赤红', value:"2" , bgColor: '-webkit-linear-gradient(left, rgba(255, 255, 0, 1.00), rgba(255, 191, 0, 1.00), rgba(255, 128, 0, 1.00), rgba(255, 64, 0, 1.00), rgba(255, 0, 0, 1.00)) ' },
                ],
                opacity: 1.0,
                colorRange: [0.0, 10.0],
                fieldRange: [0.0, 10.0],
                minMaxRange: [0.0, 10.0],
                timeValue: 0.0,
                timeTemporalCount: 10.0,
                marks: {
                    1: '1',
                    2: '2',
                    3: '3',
                    4: '4'
                },
                useArrow: false,
                arrowColor: "rgba(241,158,0,1.0)",
                isStart: false,
                direction:0.0,
                bgColorTuli:'',
                tlSteps:[]
            });

            // 要素字段和颜色表的对应键值对
            const fieldToColorObj = {
                "depth": [                       
       				{ color: "#B1D8E9", alpha: 1 },
	                { color: "#7CACD1", alpha: 1 },	                
	                { color: "#3499E5", alpha: 1 },
					{ color: "#3499E5", alpha: 1 },
                   
                ],
                "flux_density": [                	                
	                { color: "#48978F", alpha: 1 },
	                { color: "#8BCDC1", alpha: 1 },                
	                { color: "#CCEBE6", alpha: 1 },	
	                { color: "#B1D8E9", alpha: 1 },
	                { color: "#7CACD1", alpha: 1 },	                
	                { color: "#3499E5", alpha: 1 },
					{ color: "#3499E5", alpha: 1 },
                ],
                "ice_thick": [	
				{ color: "#FCFFD2", alpha: 1 },			
                { color: "#71A7B4", alpha: 1 },		
				{ color: "#4A76AE", alpha: 1 },
                ],
                "temperature": [	                
				{ color: "#4A76AE", alpha: 1 },
				{ color: "#71A7B4", alpha: 1 },
				{ color: "#A8D6A6", alpha: 1 },
				{ color: "#E3F4A4", alpha: 1 },
                { color: "#FCFFD2", alpha: 1 },		
                ]
            }

            // 基于fieldToColorObj计算颜色带选项
            for(const key in fieldToColorObj){
                const colorList = fieldToColorObj[key];
                let colorString = "";
                colorList.forEach(item => colorString += `, ${item.color}`)
                const bgColorString = `-webkit-linear-gradient(left ${colorString})`;
                const initColorString = `-webkit-linear-gradient(bottom ${colorString})`;                

                const colorObj = {
                    label:key,
                    value:key,
                    bgColor:bgColorString
                }

                state.colorOptions.push(colorObj)
            }

            let currentColorList = undefined;
            let currentTimeType = SuperMap3D.CategoryFieldName.Elevation;
            let currentField = undefined;
            let currentFieldTemporalCount = 0;

            let layer = scene.layers.find("layerName") || scene.layers.layerQueue[0];
            if (!layer) return;
            window.layer = layer;

            // 设置图层水面效果
            layer.multiTemporalUseWater = true;
            layer.waterParameter.waterbodySize = SuperMap3D.WaterbodySize.LARGE;
            layer.waterParameter.waveStrength = SuperMap3D.WaveStrength.MODERATE ;
            layer.waterParameter.flowDirectionDisplayMode = SuperMap3D.FlowDirectionDisplayMode.NONE;
            layer.waterParameter.flowDirectionArrowColor = SuperMap3D.Color.fromCssColorString("rgba(240,189,62,1)");
            // 过滤小于这个透明度的不显示，按需求设置
            layer.minTransparentAlpha = 0.0;
			
            // // 改变字段范围后隐藏底层阴影 => 其实是图层自带的填充色
            // layer.style3D.fillForeColor.alpha = 0;

            // 获取多要素字段选项
            let temporaInfos = layer.temporaInfos;

            // 获取图层字段
            Object.keys(temporaInfos).forEach((key, index) => {
                if (index === 0) state.fieldType = key;
                const label = checkLabelFromField(key);
                state.fieldOptions.push({ label: label, value: key })
            })

            function checkLabelFromField(field){
                if(field.includes('depth')){
                    return "水深";
                }else if(field.includes('temperature')){
                    return "水温";
                }else if(field.includes('ice_density')){
                    return "冰密度";
                }else if(field.includes('ice_thick')){
                    return "冰厚";
                }else if(field.includes('flux_density')){
                    return "流量密度";
                }else if(field.includes('close_state')){
                    return "关闭状态";
                }else{
                    return field;
                }
            }

            // 初始化面板数值
            currentField = Object.keys(temporaInfos)[0]; //默认先取第一个要素展示;
            updateTimeOptionsByField(currentField);
            updatePanelInfoByField(currentField);
            updateTimeScaleRangeSliderByField(currentField);
            

            currentColorList = fieldToColorObj[currentField.trim()];
            let colorString = "";

            currentColorList.forEach(item => colorString += `, ${item.color}`)
                            
			updateColor(colorString)
            state.colorType = currentField.trim();

            // 分层设色
            setLayerHyp(layer, currentField, currentColorList);


            // 切换字段时根据字段信息中的维度，限制可选的时序类型
            function updateTimeOptionsByField(field) {
                if (!layer || !field) return;

                const supportTimeTypeList = [
                    { value: "VertexWeight", dimension: 1 },
                    { value: "Velocity", dimension: 2 },
                    { value: "VertexOffset", dimension: 3 },
                ];

                const fieldInfo = layer.temporaInfos[field];
                state.timeOptions.length = 0;

                const dimension = Number(fieldInfo.dimension);
                Object.keys(SuperMap3D.CategoryFieldName).forEach((fielName) => { // 时序类型
                    const fieldValue = SuperMap3D.CategoryFieldName[fielName];
                    const target = supportTimeTypeList.find(item => item.value === fieldValue);
                    if (!target) return;

                    const option = {
                        label: target.value,
                        value: target.value,
                        disabled: target.dimension != dimension
                    }
                    state.timeOptions.push(option);
                })

                state.timeType = state.timeOptions[0].value;
            }

            // 切换要素字段时更新面板信息
            function updatePanelInfoByField(field) {
                if (!field || !layer) return;
                const fieldInfo = layer.temporaInfos[field];

                let min = fieldInfo.min[0];
                let max = fieldInfo.max[0];
                const temporalCount = fieldInfo.temporalCount;
                currentFieldTemporalCount = fieldInfo.temporalCount;
                console.log("要素字段信息:", `min:${min};  max:${max};  temporalCount:${temporalCount}`, fieldInfo);

                // min = Math.floor(min);
                // max = Math.floor(max);

                state.colorRange = [min, max];
                state.fieldRange = [min, max];
                state.minMaxRange = [min, max];
            }

            // 更新时序类型滚动条
            function updateTimeScaleRangeSliderByField(field){
                const fieldInfo = layer.temporaInfos[field];
                currentFieldTemporalCount = fieldInfo.temporalCount;  //兼容老数据11.1版本使用temporalCount
                state.timeTemporalCount = currentFieldTemporalCount;
                state.marks = splitRangeTo10Sections(0, currentFieldTemporalCount);
            }

            // 设置图层分层设色
            function setLayerHyp(layer, fieldName, colorList) {
                // return;
                if (!layer || !fieldName) return;
                if (layer.temporalSetting) {
                    layer.temporalSetting.setFieldName(currentTimeType, fieldName);
                }
                let categoryObj = temporaInfos[fieldName];
                let minValue = categoryObj.min[0];
                let maxValue = categoryObj.max[0];
                getStep(minValue,maxValue);
                updateStep();
                let hyp = new SuperMap3D.HypsometricSetting();
                hyp.ColorTable = createColorTable(minValue, maxValue, colorList);
                hyp.DisplayMode = SuperMap3D.HypsometricSettingEnum.DisplayMode.FACE;
                hyp.Opacity = 1.0;
                hyp.LineInterval = 1;
                hyp.ColorTableMaxKey = maxValue;
                hyp.ColorTableMinKey = minValue;
                hyp.MaxVisibleValue = maxValue;
                hyp.noValueColor = new SuperMap3D.Color(1, 0, 0, 0);  //无效值透明
                hyp.MinVisibleValue = minValue;
                hyp.filterMode = SuperMap3D.HypsometricSettingEnum.FilterMode.NEAREST;
                layer.hypsometricSetting = {
                    hypsometricSetting: hyp,
                    analysisMode: SuperMap3D.HypsometricSettingEnum.AnalysisRegionMode.ARM_ALL,
                };
            }

            function getStep(min,max){
                state.tlSteps = [];
                const parts = 6;
                const step = (max - min) / parts;
                
                for(let i = 0;i <= parts;i++) {
                    const value = (min + i *step).toFixed(4);
                    let str = value.toString();
                    if(str.indexOf('.') !== -1) {
                        str = str.replace(/\.?0+$/,'');
                        state.tlSteps.push(str)
                    }
                }
                state.tlSteps.reverse();
                console.log('state.tlSteps',state.tlSteps)
            }

            function updateStep() {
                let html = '';
                const colorLegend = document.getElementById('color-legend');
                state.tlSteps.forEach(item => {
                    html += `<div class="color-legend-label" >${item}</div></br>`
                })
                colorLegend.innerHTML = html;
            }
            
            function updateColor(colorString){
            	state.bgColorTuli = `-webkit-linear-gradient(bottom ${colorString}) !important`;
                const colorLegend = document.getElementById('color-legend');
                colorLegend.setAttribute("style",`background:${state.bgColorTuli}`);
            }

            // 创建颜色表
            function createColorTable(minValue, maxValue, colorList) {
                if (maxValue <= minValue || !colorList || colorList.length == 0) {
                    console.log("创建颜色表时传值错误");
                    return;
                }

                const colorTable = new SuperMap3D.ColorTable();
                const step = (maxValue - minValue) / colorList.length;
                colorList.forEach((item, index) => {
                    let inteValue = minValue + step * index;
                    // state.tlSteps.push(inteValue);
                    const interColor = SuperMap3D.Color.fromCssColorString(item.color).withAlpha(item.alpha);
                    if (index === colorList.length - 1) inteValue = maxValue; // 最好一个值使用maxValue
                    colorTable.insert(inteValue, interColor);
                });
                console.log('state.tlSteps',state.tlSteps)
                return colorTable;
            }

            // 计算时序滚动条刻度
            function splitRangeTo10Sections(start, end) {
                const min = Math.min(start, end);
                const max = Math.max(start, end);
                const step = (max - min) / 10;  // 计算步长
                const points = {};

                for (let i = 0; i <= 10; i++) {
                    // 处理浮点数精度问题（保留两位小数）
                    const value = parseFloat((min + step * i).toFixed(2));
                    points[value] = Math.floor(value);
                }

                return points;
            }


            // 底部操作按钮
            let timer;
            let isStop = false;
            let isPlay = false;

            function start() {
                state.isStart = true;

                if (isStop || isPlay) {
                    layer.temporalSetting.setLoaction(currentTimeType, 0);
                    isPlay = false;
                    isStop = false;
                    clearInterval(timer);
                    state.timeValue = 0;
                }
                timer = setInterval(() => {
                    const getLoactionValue = layer.temporalSetting.getLoaction(currentTimeType);
                    layer.temporalSetting.setLoaction(currentTimeType, getLoactionValue + 1);
                    state.timeValue = getLoactionValue;
                    if (getLoactionValue >= currentFieldTemporalCount) {
                        layer.temporalSetting.setLoaction(currentTimeType, 0);
                        clearInterval(timer);
                    }
                }, 200);
            }

            function stop() {
                clearInterval(timer);
                isStop = true;
                isPlay = false;
            }

            function continueStart() {
                if (!isStop) return;
                isPlay = true;
                isStop = false;
                timer = setInterval(() => {
                    const getLoactionValue = layer.temporalSetting.getLoaction(currentTimeType);
                    layer.temporalSetting.setLoaction(currentTimeType, getLoactionValue + 1);
                    state.timeValue = getLoactionValue;
                    if (getLoactionValue >= currentFieldTemporalCount) {
                        layer.temporalSetting.setLoaction(currentTimeType, 0);
                        clearInterval(timer);
                    }
                }, 200);
            }

            function restart() {
                state.isStart = false;
                
                layer.temporalSetting.setLoaction(currentTimeType, 0);
                if (timer) {
                    clearInterval(timer);
                }
                state.timeValue = 0;
            }

            // 渲染颜色表色带
            const renderColorTableLabel = function (option) {
                return h(
                    'div',
                    { style: 'display: flex; align-items: center; gap: 8px' },
                    [
                        h('div', {
                            style: `
                                width: 190px;
                                height: 16px;
                                background: ${option.bgColor};
                                border-radius: 3px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1)
                                `
                        })
                    ]
                );
            }

            // 创建Vue示例
            const App = {
                setup() {
                    // 要素字段切换
                    watch(() => state.fieldType,
                        (val) => {
                            currentField = val;

                            // 更新面板信息
                            updatePanelInfoByField(currentField);

                            // 更新时序类型选择项
                            updateTimeOptionsByField(currentField);

                            // 更新时序滚动条
                            updateTimeScaleRangeSliderByField(currentField);

                            // 更新图例步长
                            updateStep()
                            
                            
                            if(fieldToColorObj[currentField.trim()]){
                                // 切换颜色表 watch=> 更新分层设色效果
                                state.colorType = currentField.trim();
                            }else{
                                // 更新分层设色效果
                                setLayerHyp(layer, currentField, currentColorList);
                            }
                            
                            state.filedNameByTL = checkLabelFromField(currentField)
                            switch(state.filedNameByTL) {
                                case "水深":
                                    return state.filedNameByTL += "(m)";
                                    break;
                                case "冰厚":
                                    return state.filedNameByTL += "(m)";
                                    break;
                                case "冰密度":
                                    return state.filedNameByTL += "(kg/m³)";
                                    break;
                                case "流量密度":
                                    return state.filedNameByTL += "(kg/m³)";
                                    break;
                                case "水温":
                                    return state.filedNameByTL += "(℃)";
                                    break;
                                case "关闭状态":
                                    return state.filedNameByTL;
                                    break;
                                
                            }
                        }
                    );

                    // 时序类型切换
                    watch(() => state.timeType,
                        (val) => {
                            currentTimeType = val;

                            // 更新分层设色效果
                            setLayerHyp(layer, field, currentColorList);
                        }
                    );

                    // 颜色表切换
                    watch(() => state.colorType,
                        (val) => {
                            const colorList = fieldToColorObj[val];
                            if(colorList) currentColorList = colorList;
                            let colorString = "";

                            currentColorList.forEach(item => colorString += `, ${item.color}`)
                            
							updateColor(colorString)
                            setLayerHyp(layer, currentField, currentColorList);
                        }
                    );

                    // 透明度
                    watch(() => state.opacity,
                        (val) => {
                            layer.hypsometricSetting.hypsometricSetting.Opacity = Number(val)
                        }
                    );

                    // 颜色表范围
                    watch(
                        () => state.colorRange,
                        (val) => {
                            const range = val;
                            if (range.length === 2) {
                                layer.hypsometricSetting.hypsometricSetting.ColorTableMinKey = Number(range[0])
                                layer.hypsometricSetting.hypsometricSetting.ColorTableMaxKey = Number(range[1])
                            }
                        }
                    );

                    // 字段范围
                    watch(
                        () => state.fieldRange,
                        (val) => {
                            const range = val;
                            if (range.length === 2) {
                                layer.hypsometricSetting.hypsometricSetting.MinVisibleValue = Number(range[0])
                                layer.hypsometricSetting.hypsometricSetting.MaxVisibleValue = Number(range[1])
                            }
                        }
                    );
                    
                    watch(() => state.direction,
                        (val) => {
                            layer.waterParameter.waveDirection = Number(val);
                        }
                    );

                    // 水面箭头显隐
                    watch(() => state.useArrow,
                        (val) => {
                            const FlowDirectionDisplayMode = SuperMap3D.FlowDirectionDisplayMode;
                            if (val) {
                                layer.waterParameter.flowDirectionDisplayMode = FlowDirectionDisplayMode.ARROW;
                            } else {
                                layer.waterParameter.flowDirectionDisplayMode = FlowDirectionDisplayMode.NONE;
                            }
                        }
                    );

                    // 水面箭头颜色
                    watch(() => state.arrowColor,
                        (val) => {
                            const selectColor = new SuperMap3D.Color.fromCssColorString(val);
                            layer.waterParameter.flowDirectionArrowColor = selectColor;
                        }
                    );

                    // 拖动时序滚动条
                    watch(() => state.timeValue,
                        (val) => {
                            if (Number(val) >= currentFieldTemporalCount) { } else {
                                let value = parseInt(val);
                                layer.temporalSetting.setLoaction(currentTimeType, value);
                            }
                        }
                    );
                    

                    return {
                        state,
                        darkTheme,
                        start,
                        stop,
                        continueStart,
                        restart,
                        renderColorTableLabel,
                        overridesTheme: { // 重写主题样式
                            common: {
                                primaryColor: "rgba(52, 153, 229, 1)",
                                primaryColorHover: "rgba(52, 153, 229, 1)",
                                primaryColorPressed: "rgba(255,255,255,0.85)",
                                primaryColorSuppl: "rgba(255,255,255,0.45)",
                            },
                            Button: {
                                fontSizeMedium: "14px", // 底部操作按钮：宽高和文字大小自适应浏览器
                                textColor: "rgba(255,255,255,0.65)", // 设置默认n-button全局样式
                                border: "1px solid rgba(255,255,255,0.65)",
                                textColorHover: "#5EB7F2",
                                borderHover: "1px solid #5EB7F2",
                                textColorPressed: "#2276BF",
                                borderPressed: "1px solid #2276BF",
                            },
                            Tabs: {
                                barColor: "#3499e5", // tabs底部横条颜色
                                tabFontSizeMedium: "14px", // tabs标签文字大小 - 兼容移动端样式
                            },
                            ColorPicker: {
                                border: "none", // color-pick颜色条去掉边框
                            },
                            Divider: {
                                color: "rgba(255, 255, 255, 0.15)", // 分割条颜色
                            },
                            Checkbox: {
                                colorChecked: "#3499E5",
                                checkMarkColor: "#fff",
                            },
                            Slider: {
                                fillColor: "#3499E5",
                                fillColorHover: "#3499E5",
                                handleSize: "12px",
                            },
                            Switch: {
                                railColorActive: "#3499E5",
                            },
                            Select: {
                                color: "rgba(255, 255, 255, 0.15)"
                            }
                        },
                    }
                }
            }
            const app = Vue.createApp(App);
            app.use(naive);
            app.mount('#app');
        }

        if (typeof SuperMap3D !== 'undefined') {
            window.startupCalled = true;
            onload(SuperMap3D);
        }
    </script>
</body>

</html>