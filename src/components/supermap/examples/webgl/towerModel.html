<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <title>实例化图层编辑</title>
    <link href="../../Build/SuperMap3D/Widgets/widgets.css" rel="stylesheet">
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <link href="./css/pretty.css" rel="stylesheet">
    <link href="./style/towerModel.css" rel="stylesheet">
    <script src="./js/jquery.min.js"></script>
    <script src="./js/bootstrap.min.js"></script>
    <script src="./js/tooltip.js"></script>
    <script src="./js/config.js"></script>
    <script src="./js/spectrum.js"></script>
    <script type="text/javascript" src="../../Build/SuperMap3D/SuperMap3D.js"></script>
</head>

<body>
    <div id="Container"></div>
    <div class="toolbar-container">
        <div class="toolbar-header">
            <div class="toolbar-header-title">实例化图层编辑</div>
            <span class="toolbar-header-close" id="close">X</span>
        </div>
        <div class="toolbar-content">
            <div class="inputBox">
                <label class="lab" for="colorTable">选中颜色</label>
                <input class="content" id="colorPicker">
            </div>
            <div class="inputBox">
                <label class="lab" for="colorTable">平移（X轴）</label>
                <input class="content" type="number" id="transX" value="1" step="1" >
                <span style="position: absolute;top: 119px;left: 286px; color: rgba(255, 255, 255, 0.45);">米</span>
            </div>
            <div class="inputBox">
                <label class="lab" for="colorTable">平移（Y轴）</label>
                <input class="content" type="number" id="transY" value="1" step="1">
                <span style="position: absolute;top: 169px;left: 286px; color: rgba(255, 255, 255, 0.45);">米</span>
            </div>
            <div class="inputBox">
                <label class="lab" for="colorTable">平移（Z轴）</label>
                <input class="content" type="number" id="transZ" value="1" step="1">
                <span style="position: absolute;top: 219px;left: 286px; color: rgba(255, 255, 255, 0.45);">米</span>
            </div>
            <div class="inputBox">
                <label class="lab" for="colorTable">旋转（Z轴）</label>
                <input class="content" type="number" id="rotateZ" min="-360" max="360" value="1" step="1">
                <span style="position: absolute;top: 269px;left: 286px; color: rgba(255, 255, 255, 0.45);">度</span>
            </div>
            <div class="inputBox">
                <label class="lab" for="colorTable">等比缩放</label>
                <input class="content" type="number" id="scale" min="-2" max="2" value="1.0" step="0.1" >
            </div>
        </div>
        <div class="tree-footer">

        </div>
    </div>


    <div id='loadingbar' class="spinner">
        <div class="spinner-container container1">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
        <div class="spinner-container container2">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
        <div class="spinner-container container3">
            <div class="circle1"></div>
            <div class="circle2"></div>
            <div class="circle3"></div>
            <div class="circle4"></div>
        </div>
    </div>
    <script>
        /*
         * 1. 对每个塔以及相关联的绝缘子串、放样线进行分组
         * 2. 修改塔时对塔以及相关联的绝缘子串、放样线进行本地坐标系下的平移 旋转 缩放
         * */
         function onload(SuperMap3D) {
            // 通过config.js中的getEngineType,获取引擎类型（EngineType）用于设置启动方式
            let EngineType = getEngineType();
            let viewer = new SuperMap3D.Viewer('Container', {
                contextOptions: {
                    contextType: Number(EngineType), // Webgl2:2 ; WebGPU:3
                },
                infoBox: false,
                selectionIndicator: false,
                timeline: true,
                navigation: false
            });

            viewer.scenePromise.then(function (scene) {
                init(SuperMap3D, scene, viewer);
            });
        }

        function init(SuperMap3D, scene, viewer) {
            window.viewer = viewer;
            viewer.resolutionScale = window.devicePixelRatio;
            // scene.globe.globeAlpha = 0.5; // 地表透明度
            viewer.camera.setView({
                "destination": {
                    "x": -1248485.593181022,
                    "y": 5614561.045170093,
                    "z": 2747554.758192463
                },
                "orientation": {
                    "heading": 5.524834879879968,
                    "pitch": -0.10066255392832346,
                    "roll": 3.047319934168513e-7
                }
            });

            // 加载高德影像地图
            viewer.imageryLayers.addImageryProvider(new SuperMap3D.UrlTemplateImageryProvider({
                url: 'https://webst02.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
                minimumLevel: 3,
                maximumLevel: 18,
            }));

            // 整个切片 距离过滤
            const instanceLayer = new SuperMap3D.InstanceLayer(scene._context);
            scene.primitives.add(instanceLayer);
            instanceLayer.minVisibleAltitude = 0;
            instanceLayer.maxVisibleAltitude = 10000;
            instanceLayer.filterMode = 0;
            instanceLayer.filterPixel = 0; // 对象过滤
            instanceLayer.filterDistance = 8000;
            instanceLayer.tileWidth = 5500;
            instanceLayer.pickEnable = true;
            instanceLayer.selectedColor = SuperMap3D.Color.fromCssColorString("rgb(58,58,243)");

            // 用于保存电力塔及其构件
            const groups = new Map();

            // 实体选中事件
            const screenSpaceEventHandler = new SuperMap3D.ScreenSpaceEventHandler(scene.canvas);
            screenSpaceEventHandler.setInputAction(function (e) {
                if (SuperMap3D.defined(viewer.selectedEntity)) {
                    console.log('选中的Entity:', viewer.selectedEntity);
                }
            }, SuperMap3D.ScreenSpaceEventType.LEFT_CLICK);

            // 颜色选择
            $("#colorPicker").spectrum({
                color: "rgba(58,58,243,1)",
                showPalette: true,
                showAlpha: true,
                localStorageKey: "spectrum.demo",
                preferredFormat: 'rgb'
            });
            $("#colorPicker").on('change', function (event) {
                var selectColor = new SuperMap3D.Color.fromCssColorString(event.target.value);
                instanceLayer.selectedColor = selectColor;
            });

            // 待数据加载场景渲染完成后加载初始化事件
            function ModelEditHandle() {
                // 平移
                let transX_step = 0;
                $("#transX").on("input change", function () {
                    if (viewer.selectedEntity) {
                        let transX_number = Number(this.value) - transX_step; // 真正需要移动的距离

                        let curInstance = viewer.selectedEntity.primitive;
                        MoveInstances(curInstance, transX_number , 0, 0);

                        transX_step = Number(this.value);
                    }
                });
                let transY_step = 0;
                $("#transY").on("input change", function () {
                    if (viewer.selectedEntity) {
                        let transY_number = Number(this.value) - transY_step; 

                        let curInstance = viewer.selectedEntity.primitive;
                        MoveInstances(curInstance, 0, Number(transY_number), 0);

                        transY_step = Number(this.value);
                    }
                });
                let transZ_step = 0;
                $("#transZ").on("input change", function () {
                    if (viewer.selectedEntity) {
                        let transZ_number = Number(this.value) - transZ_step; 

                        let curInstance = viewer.selectedEntity.primitive;
                        MoveInstances(curInstance, 0, 0, Number(transZ_number));

                        transZ_step = Number(this.value);
                    }
                });

                // 旋转
                let rotateZ_degree = 0;
                $("#rotateZ").on("input change", function () {
                    if (viewer.selectedEntity) {
                        let rotateZ_number = Number(this.value) - rotateZ_degree; // 真正需要旋转的角度

                        let curInstance = viewer.selectedEntity.primitive;
                        let rotation_matrix = SuperMap3D.Matrix3.fromRotationZ(SuperMap3D.Math.toRadians(rotateZ_number)); // 转换为弧度
                        RotateInstances(curInstance, rotation_matrix);
                        
                        rotateZ_degree = Number(this.value);
                    }
                });

                // 缩放
                let scale_step = 0;
                $("#scale").on("change", function () {
                    if (viewer.selectedEntity) {
                        let curInstance = viewer.selectedEntity.primitive;
                        ScaleInstences(curInstance, Number(this.value));
                    }
                });


                // 平移模型
                function MoveInstances(towerInstance, x, y, z) {
                    let instanceArr = groups.get(towerInstance);
                    let insulatorArr = []; // 绝缘子串
                    let wireArr = []; // 放样线
                    for (let i = 1; i < instanceArr.length; i++) {
                        if (instanceArr[i] instanceof SuperMap3D.Instance) {
                            insulatorArr.push(instanceArr[i]);
                        } else {
                            wireArr.push(instanceArr[i]);
                        }
                    }
                    // 先修改线，因为线慢
                    for (let j = 0; j < wireArr.length; j++) {
                        let instance = wireArr[j];
                        let tag = instance[0];
                        let entity = instance[1];
                        let catenaryline = instance[2];
                        let offset = new SuperMap3D.Cartesian3(x, y, z);
                        updateWirePositionsByTrans(catenaryline, entity, tag, offset);
                    }

                    // 修改模型
                    setTimeout(function () {
                        for (let k = 0; k < insulatorArr.length; k++) {
                            let instance = insulatorArr[k];
                            let enu = SuperMap3D.Transforms.eastNorthUpToFixedFrame(instance.position, SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                            let offset = new SuperMap3D.Cartesian3(x, y, z);
                            let newPos = SuperMap3D.Matrix4.multiplyByPoint(enu, offset, new SuperMap3D.Cartesian3());
                            instance.updatePosition(newPos);
                            instance.updateModelMatrix(instance.matrix);
                        }
                    }, 200); // 设置延时是因为线修改位置的性能稍慢些，过一会儿再修改模型的位置；不同机器上这里要调整一下
                }

                // 旋转模型
                function RotateInstances(towerInstance, rotation_matrix) {
                    let instanceArr = groups.get(towerInstance);
                    let insulatorArr = []; // 绝缘子串
                    let wireArr = []; // 放样线
                    for (let i = 1; i < instanceArr.length; i++) {
                        if (instanceArr[i] instanceof SuperMap3D.Instance) {
                            insulatorArr.push(instanceArr[i]);
                        } else {
                            wireArr.push(instanceArr[i]);
                        }
                    }

                    // 电力塔变换
                    let towerMatrix = SuperMap3D.Matrix4.multiplyByMatrix3(towerInstance.matrix, rotation_matrix, new SuperMap3D.Matrix4());
                    towerInstance.updateModelMatrix(towerMatrix);
                    towerInstance.matrix = towerMatrix;

                    // 电力塔中心点(本地坐标系原点)
                    let center = towerInstance.position;

                    // 先修改线，因为线慢
                    for (let j = 0; j < wireArr.length; j++) {
                        let instance = wireArr[j];
                        let tag = instance[0];
                        let entity = instance[1];
                        let catenaryline = instance[2];
                        updateWirePositionsByRotate(catenaryline, entity, tag, center, towerMatrix, rotation_matrix);
                    }

                    // 子构件变换
                    for (let k = 1; k < insulatorArr.length; k++) {
                        let instance = insulatorArr[k];

                        /** 基于电塔中心点当作原点,建立局部(本地)坐标系 **/
                        let world_position_new = ComputedNewWorldPositionAfterLocalRotate(center, towerMatrix, rotation_matrix, instance.position)

                        // 更新构件跟随电塔旋转后的世界坐标系
                        instance.updatePosition(world_position_new);

                        // 构件本身模型的旋转
                        let new_model_matrix = SuperMap3D.Matrix4.multiplyByMatrix3(instance.matrix, rotation_matrix, new SuperMap3D.Matrix4());
                        instance.updateModelMatrix(new_model_matrix);
                        instance.matrix = new_model_matrix;
                    }
                }

                // 缩放模型
                function ScaleInstences(towerInstance, scale_number) {
                    let instanceArr = groups.get(towerInstance);
                    let insulatorArr = []; // 绝缘子串
                    let wireArr = []; // 放样线
                    for (let i = 1; i < instanceArr.length; i++) {
                        if (instanceArr[i] instanceof SuperMap3D.Instance) {
                            insulatorArr.push(instanceArr[i]);
                        } else {
                            wireArr.push(instanceArr[i]);
                        }
                    }

                    // 电力塔中心点(本地坐标系原点)
                    let center = towerInstance.position;

                    // 先修改线，因为线慢
                    for (let j = 0; j < wireArr.length; j++) {
                        let instance = wireArr[j];
                        let tag = instance[0];
                        let entity = instance[1];
                        let catenaryline = instance[2];
                        updateWirePositionsByScale(catenaryline, entity, tag, center, scale_number);
                    }

                    let scale = new SuperMap3D.Cartesian3(scale_number, scale_number, scale_number);
                    let instance_matrix = towerInstance.matrix;
                    let matrix4d = SuperMap3D.Matrix4.multiplyByScale(instance_matrix, scale, new SuperMap3D.Matrix4());
                    towerInstance.updateModelMatrix(matrix4d);
                    towerInstance.matrix = matrix4d;

                    for (let k = 1; k < insulatorArr.length; k++) {
                        let instance = insulatorArr[k];

                        /** 基于电塔中心点当作原点,建立局部(本地)坐标系 **/
                        let world_position_new = ComputedNewWorldPositionAfterLocalScale(center, scale_number, instance.position)
                        instance.updatePosition(world_position_new);

                        // 构件本身的缩放
                        let instance_matrix = instance.matrix;
                        let matrix4d = SuperMap3D.Matrix4.multiplyByScale(instance_matrix, scale, new SuperMap3D.Matrix4());
                        instance.updateModelMatrix(matrix4d);
                        instance.matrix = matrix4d;
                    }
                }

                // 平移后更新电线坐标
                function updateWirePositionsByTrans(catenaryline, entity, tag, offset) {
                    let length = entity._polyline._positions._value.length;
                    let polylineStartPosition = entity._polyline._positions._value[0];
                    let polylineEndPosition = entity._polyline._positions._value[length - 1];
                    let polylineVolumeStartPosition = entity._polylineVolume._positions._value[0];
                    let polylineVolumeEndPosition = entity._polylineVolume._positions._value[length - 1];

                    if (tag === "start") {
                        let enu = SuperMap3D.Transforms.eastNorthUpToFixedFrame(polylineStartPosition, SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                        let polylineStartPositionNew = SuperMap3D.Matrix4.multiplyByPoint(enu, offset, new SuperMap3D.Cartesian3());

                        let enu3 = SuperMap3D.Transforms.eastNorthUpToFixedFrame(polylineVolumeStartPosition, SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                        let polylineVolumeStartPositionNew = SuperMap3D.Matrix4.multiplyByPoint(enu3, offset, new SuperMap3D.Cartesian3());

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPositionNew, polylineEndPosition);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPositionNew, polylineVolumeEndPosition);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    } else if (tag === "end") {
                        let enu2 = SuperMap3D.Transforms.eastNorthUpToFixedFrame(polylineEndPosition, SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                        let polylineEndPositionNew = SuperMap3D.Matrix4.multiplyByPoint(enu2, offset, new SuperMap3D.Cartesian3());

                        let enu4 = SuperMap3D.Transforms.eastNorthUpToFixedFrame(polylineVolumeEndPosition, SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                        let polylineVolumeEndPositionNew = SuperMap3D.Matrix4.multiplyByPoint(enu4, offset, new SuperMap3D.Cartesian3());

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPosition, polylineEndPositionNew);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPosition, polylineVolumeEndPositionNew);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    }
                }

                // 旋转后更新电线坐标
                function updateWirePositionsByRotate(catenaryline, entity, tag, center, towerMatrix, rotation_matrix) {
                    let length = entity._polyline._positions._value.length;
                    let polylineStartPosition = entity._polyline._positions._value[0];
                    let polylineEndPosition = entity._polyline._positions._value[length - 1];
                    let polylineVolumeStartPosition = entity._polylineVolume._positions._value[0];
                    let polylineVolumeEndPosition = entity._polylineVolume._positions._value[length - 1];

                    if (tag === "start") {
                        let polylineStartPositionNew = ComputedNewWorldPositionAfterLocalRotate(center, towerMatrix, rotation_matrix, polylineStartPosition);
                        let polylineVolumeStartPositionNew = ComputedNewWorldPositionAfterLocalRotate(center, towerMatrix, rotation_matrix, polylineVolumeStartPosition);

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPositionNew, polylineEndPosition);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPositionNew, polylineVolumeEndPosition);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    } else if (tag === "end") {
                        let polylineEndPositionNew = ComputedNewWorldPositionAfterLocalRotate(center, towerMatrix, rotation_matrix, polylineEndPosition);
                        let polylineVolumeEndPositionNew = ComputedNewWorldPositionAfterLocalRotate(center, towerMatrix, rotation_matrix, polylineVolumeEndPosition);

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPosition, polylineEndPositionNew);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPosition, polylineVolumeEndPositionNew);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    }
                }

                // 缩放后更新电线坐标
                function updateWirePositionsByScale(catenaryline, entity, tag, center, scale_number) {
                    let length = entity._polyline._positions._value.length;
                    let polylineStartPosition = entity._polyline._positions._value[0];
                    let polylineEndPosition = entity._polyline._positions._value[length - 1];
                    let polylineVolumeStartPosition = entity._polylineVolume._positions._value[0];
                    let polylineVolumeEndPosition = entity._polylineVolume._positions._value[length - 1];

                    if (tag === "start") {
                        let polylineStartPositionNew = ComputedNewWorldPositionAfterLocalScale(center, scale_number, polylineStartPosition);
                        let polylineVolumeStartPositionNew = ComputedNewWorldPositionAfterLocalScale(center, scale_number, polylineVolumeStartPosition);

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPositionNew, polylineEndPosition);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPositionNew, polylineVolumeEndPosition);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    } else if (tag === "end") {
                        let polylineEndPositionNew = ComputedNewWorldPositionAfterLocalScale(center, scale_number, polylineEndPosition);
                        let polylineVolumeEndPositionNew = ComputedNewWorldPositionAfterLocalScale(center, scale_number, polylineVolumeEndPosition);

                        let polylinePts = calcNewPositions(catenaryline, polylineStartPosition, polylineEndPositionNew);
                        let polylineVolumePts = calcNewPositions(catenaryline, polylineVolumeStartPosition, polylineVolumeEndPositionNew);
                        entity.polyline.positions = polylinePts;
                        entity.polylineVolume.positions = polylineVolumePts;
                    }
                }

                // 根据起始点计算坐标
                function calcNewPositions(catenaryline, startPosition, endPosition) {
                    let startPositionNewCartographic = SuperMap3D.Cartographic.fromCartesian(startPosition);
                    let lonStart = SuperMap3D.Math.toDegrees(startPositionNewCartographic.longitude);
                    let latStart = SuperMap3D.Math.toDegrees(startPositionNewCartographic.latitude);
                    let heightStart = startPositionNewCartographic.height;
                    let startPositionPt = new SuperMap3D.Cartesian3(lonStart, latStart, heightStart);
                    let endPositionNewCartographic = SuperMap3D.Cartographic.fromCartesian(endPosition);
                    let lonEnd = SuperMap3D.Math.toDegrees(endPositionNewCartographic.longitude);
                    let latEnd = SuperMap3D.Math.toDegrees(endPositionNewCartographic.latitude);
                    let heightEnd = endPositionNewCartographic.height;
                    let endPositionPt = new SuperMap3D.Cartesian3(lonEnd, latEnd, heightEnd);
                    let tmpPts = catenaryline.InsertTwoPoints(startPositionPt, endPositionPt);
                    let pts = [];
                    for (let j = 0; j < tmpPts.length; j++) {
                        pts.push(SuperMap3D.Cartesian3.fromDegrees(tmpPts[j].x, tmpPts[j].y, tmpPts[j].z));
                    }
                    return pts;
                }

                // 计算指定原点的本地坐标系下,经过旋转变换后的世界坐标
                function ComputedNewWorldPositionAfterLocalRotate(origin, towerMatrix, rotation_matrix, pre_position) {
                    // 本地坐标到世界坐标的变换矩阵
                    let local_to_world_matrix = SuperMap3D.Transforms.eastNorthUpToFixedFrame(origin);

                    // 由于电力塔和构件模型矩阵不一样，所对应的XY轴也不一样，且模型矩阵也不是相对世界坐标系的，所以取出电力塔的旋转矩阵，以便同步XY轴
                    let tower_rotation = SuperMap3D.Matrix4.getRotation(towerMatrix, new SuperMap3D.Matrix3());

                    // 坐标系转换矩阵 X 同步XY轴的旋转矩阵 = 这才是正确的本地转世界矩阵
                    local_to_world_matrix_direct = SuperMap3D.Matrix4.multiplyByMatrix3(local_to_world_matrix, tower_rotation, new SuperMap3D.Matrix4());

                    // 基于正确的转换矩阵取逆，得到世界转本地的正确坐标
                    let world_to_local_matrix = SuperMap3D.Matrix4.inverse(local_to_world_matrix_direct, new SuperMap3D.Matrix4()); // 坐标系取反以便转换

                    // 本地坐标系下的坐标
                    let local_position = SuperMap3D.Matrix4.multiplyByPoint(world_to_local_matrix, pre_position, new SuperMap3D.Cartesian3())

                    // 法二 本地转世界矩阵 X 共用的旋转矩阵
                    let rotation_trans_matrix = SuperMap3D.Matrix4.multiplyByMatrix3(local_to_world_matrix_direct, rotation_matrix, new SuperMap3D.Matrix4());
                    let world_position_new = SuperMap3D.Matrix4.multiplyByPoint(rotation_trans_matrix, local_position, new SuperMap3D.Cartesian3())

                    // 返回变换后的世界坐标系位置
                    return world_position_new;
                }

                // 计算指定原点的本地坐标系下,经过缩放变换后的世界坐标
                function ComputedNewWorldPositionAfterLocalScale(origin, scale_number, pre_position) {
                    let local_to_world_matrix = SuperMap3D.Transforms.eastNorthUpToFixedFrame(origin);
                    let world_to_local_matrix = SuperMap3D.Matrix4.inverse(local_to_world_matrix, new SuperMap3D.Matrix4());

                    let local_position = SuperMap3D.Matrix4.multiplyByPoint(world_to_local_matrix, pre_position, new SuperMap3D.Cartesian3())

                    // 对本地坐标系下的向量做缩放(这里无需矩阵)
                    local_position_scale = SuperMap3D.Cartesian3.multiplyByScalar(local_position, scale_number, new SuperMap3D.Cartesian3());

                    let world_position_new = SuperMap3D.Matrix4.multiplyByPoint(local_to_world_matrix, local_position_scale, new SuperMap3D.Cartesian3())

                    return world_position_new;
                }
            }

            // 读取JSON,加载模型
            SuperMap3D.loadJson('./data/towerData/tower_five.json').then(function (data) {
                let result = data.Towers;
                for (let i = 0, j = result.length; i < j; i++) {
                    let towersUrl = './data/towerData/s3mb/tower/' + result[i].URL + ".s3mb";
                    let ID = result[i].ID;
                    let GUID = result[i].GUID;
                    let Name = result[i].Name;
                    let Lng = result[i].Lng;
                    let Lat = result[i].Lat;
                    let Height = result[i].Height;
                    let LocalMatrix = result[i].LocalMatrix;
                    let matrixstr = LocalMatrix.split('#');
                    let matrix4d = new SuperMap3D.Matrix4(
                        Number(matrixstr[0]), Number(matrixstr[4]), Number(matrixstr[8]), Number(matrixstr[12]),
                        Number(matrixstr[1]), Number(matrixstr[5]), Number(matrixstr[9]), Number(matrixstr[13]),
                        Number(matrixstr[2]), Number(matrixstr[6]), Number(matrixstr[10]), Number(matrixstr[14]),
                        Number(matrixstr[3]), Number(matrixstr[7]), Number(matrixstr[11]), Number(matrixstr[15])
                    );

                    instanceLayer.add(towersUrl, {
                        id: GUID,
                        position: new SuperMap3D.Cartesian3.fromDegrees(Number(Lng), Number(Lat), Number(Height))
                    });

                    let towerInstance = instanceLayer.getInstance(towersUrl, GUID);
                    towerInstance.updateModelMatrix(matrix4d);
                    towerInstance.matrix = matrix4d;

                    let center = new SuperMap3D.Cartesian3.fromDegrees(Number(Lng), Number(Lat), Number(Height) + 50);
                    let boundingSphere = new SuperMap3D.BoundingSphere(center, 50);
                    groups.set(towerInstance, [boundingSphere, towerInstance]);
                }
            }).then(function () {
                SuperMap3D.loadJson('./data/towerData/insulator_five.json').then(function (data) {
                    let result = data.Insulators;
                    for (let i = 0, j = result.length; i < j; i++) {
                        let insulatorsUrl = './data/towerData/s3mb/insulator/' + result[i].URL + ".s3mb";
                        let ID = result[i].ID;
                        let GUID = result[i].GUID;
                        let Name = result[i].Name;
                        let Lng = result[i].Lng;
                        let Lat = result[i].Lat;
                        let Height = result[i].Height;
                        let LocalMatrix = result[i].LocalMatrix;
                        let matrixstr = LocalMatrix.split('#');
                        let matrix4d = new SuperMap3D.Matrix4(
                            Number(matrixstr[0]), Number(matrixstr[4]), Number(matrixstr[8]), Number(matrixstr[12]),
                            Number(matrixstr[1]), Number(matrixstr[5]), Number(matrixstr[9]), Number(matrixstr[13]),
                            Number(matrixstr[2]), Number(matrixstr[6]), Number(matrixstr[10]), Number(matrixstr[14]),
                            Number(matrixstr[3]), Number(matrixstr[7]), Number(matrixstr[11]), Number(matrixstr[15])
                        );

                        // 分解模型矩阵:平移矩阵+缩放矩阵+旋转矩阵
                        let c3_tans = SuperMap3D.Matrix4.getTranslation(matrix4d, new SuperMap3D.Cartesian3());
                        let c3_scale = SuperMap3D.Matrix4.getScale(matrix4d, new SuperMap3D.Cartesian3());
                        let m3_rotation = SuperMap3D.Matrix4.getRotation(matrix4d, new SuperMap3D.Matrix3());
                        let m4_rotation = SuperMap3D.Matrix4.fromRotationTranslation(m3_rotation);

                        // 基于平移矩阵,计算出该构件在场景中的真实坐标(这里的lng/lat是电力塔的中心点,需要经过构件的模型矩阵转换到真实(恰当)位置)
                        let enu = SuperMap3D.Transforms.eastNorthUpToFixedFrame(new SuperMap3D.Cartesian3.fromDegrees(Number(Lng), Number(Lat), Number(Height)), SuperMap3D.Ellipsoid.WGS84, new SuperMap3D.Matrix4());
                        let offset = c3_tans;
                        let newPos = SuperMap3D.Matrix4.multiplyByPoint(enu, offset, new SuperMap3D.Cartesian3());

                        // 基于真实坐标加载instence(方便后面缩放时与电力塔中心点进行向量运算)
                        instanceLayer.add(insulatorsUrl, {
                            id: GUID,
                            position: newPos
                        });

                        // 将分解后的旋转矩阵作为新的模型矩阵
                        let insulatorInstance = instanceLayer.getInstance(insulatorsUrl, GUID);
                        insulatorInstance.updateModelMatrix(m4_rotation);
                        insulatorInstance.updateScale(c3_scale);
                        insulatorInstance.matrix = m4_rotation;

                        let center = SuperMap3D.Cartesian3.fromDegrees(Number(Lng), Number(Lat), Number(Height) + 50);
                        let insulatorBs = new SuperMap3D.BoundingSphere(center, 10);
                        for (let towerInstance of groups.keys()) {
                            let arr = groups.get(towerInstance);
                            let bs = arr[0];
                            let tmpBs = SuperMap3D.BoundingSphere.union(insulatorBs, bs);
                            if (tmpBs.radius === bs.radius) {
                                arr.push(insulatorInstance);
                                break;
                            }
                        }
                    }
                })
            }).then(function () {
                SuperMap3D.loadJson('./data/towerData/wire_five.json').then(function (data) {
                    let result = data.Wires;
                    for (let i = 0, j = result.length; i < j; i++) {
                        let ID = result[i].ID;
                        if (ID === "2835" || ID === "2774" || ID === "2775") { // 异常数据
                            continue;
                        }
                        let GUID = result[i].GUID;
                        let Name = result[i].Name;
                        let StartPoints = result[i].StartPoints;
                        let EndPoints = result[i].EndPoints;
                        let LineColor = result[i].Color;
                        let KValue = result[i].KValue;
                        let LineRadius = result[i].Radius;
                        let startPoints = StartPoints.split('#');
                        let endPoints = EndPoints.split('#');
                        let startCartesian3 = SuperMap3D.Cartesian3.fromDegrees(Number(startPoints[0]), Number(startPoints[1]), Number(startPoints[2]));
                        let endCartesian3 = SuperMap3D.Cartesian3.fromDegrees(Number(endPoints[0]), Number(endPoints[1]), Number(endPoints[2]));
                        let dis = SuperMap3D.Cartesian3.distance(startCartesian3, endCartesian3);
                        ////////////////////////////////////////////////////
                        // 针对数据，做了一些特殊处理，使得创建的垂线效果更好
                        let t;
                        if (dis > 900) {
                            t = 0.5;
                        } else if (dis > 600) {
                            t = 1;
                        } else if (dis > 500) {
                            t = 2;
                        } else if (dis > 200) {
                            t = 3;
                        }

                        let entityNeedToModifyCurve = {
                            '2881': 1.5,
                            '2882': 1.5,
                            '2883': 1.5,
                            '2884': 1.5,
                            '2885': 1.5,
                            '2886': 1.5,
                            '2887': 1.5,
                            '2888': 1.5,
                            '2889': 1.5,

                            '2890': 0.4,
                            '2891': 0.4,
                            '2892': 0.4,
                            '2893': 0.4,
                            '2894': 0.4,
                            '2895': 0.4,
                            '2896': 0.4,
                            '2897': 0.4,
                            '2898': 0.4,
                        };
                        if (ID in entityNeedToModifyCurve) {
                            t = entityNeedToModifyCurve[ID];
                        }
                        //////////////////////////////////////////////////////////////////
                        let catenaryLine = new SuperMap3D.Catenaryline(Number(KValue) * t); // 放样的构造函数
                        catenaryLine.NumInter = 8;
                        let psArray = [
                            {
                                begin: new SuperMap3D.Cartesian3(Number(startPoints[0]), Number(startPoints[1]), Number(startPoints[2])),
                                end: new SuperMap3D.Cartesian3(Number(endPoints[0]), Number(endPoints[1]), Number(endPoints[2]))
                            }
                        ];
                        let entityArray = catenaryLine.gernerateCatenarylines({
                            points: psArray,
                            volumeDisplayCondition: new SuperMap3D.Cartesian2(12000, 50000),
                            lineDisplayCondition: new SuperMap3D.Cartesian2(0, 12000)
                        });
                        entityArray[0]._id = ID;
                        for (let k = 0; k < entityArray.length; k++) {
                            viewer.entities.add(entityArray[k]);
                        }

                        let startCartesian = SuperMap3D.Cartesian3.fromDegrees(Number(startPoints[0]), Number(startPoints[1]), Number(startPoints[2]));
                        let endCartesian = SuperMap3D.Cartesian3.fromDegrees(Number(endPoints[0]), Number(endPoints[1]), Number(endPoints[2]));
                        let startBs = new SuperMap3D.BoundingSphere(startCartesian, 1);
                        let endBs = new SuperMap3D.BoundingSphere(endCartesian, 1);
                        for (let towerInstance of groups.keys()) {
                            let arr = groups.get(towerInstance);
                            let bs = arr[0];
                            let tmpStartUnion = SuperMap3D.BoundingSphere.union(startBs, bs);
                            let tmpEndUnion = SuperMap3D.BoundingSphere.union(endBs, bs);

                            if (tmpEndUnion.radius == bs.radius) {
                                arr.push(["end", entityArray[0], catenaryLine]);
                            } else if (tmpStartUnion.radius == bs.radius) {
                                arr.push(["start", entityArray[0], catenaryLine]);
                            }
                        }
                    }
                }).then(function () {
                    ModelEditHandle();
                    $('#loadingbar').remove();
                });
            });
        }

        if (typeof SuperMap3D !== 'undefined') {
            window.startupCalled = true;
            onload(SuperMap3D);
        }
    </script>
</body>

</html>